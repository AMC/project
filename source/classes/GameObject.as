package classes{	import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.utils.getTimer;	import flash.filters.GlowFilter;	import flash.display.DisplayObject;	import flash.events.Event;		public class GameObject extends MovieClip	{		private var animation:LinkedList;		private var animationTimer:Timer;				public var value:int = -1;				public function getX() : Number { return x; }		public function getY() : Number { return y; }		public function getWidth() : Number { return width; }		public function getHeight() : Number { return height; }				public function setScale(num:Number) { scaleX = num; scaleY = num; }		public function setPosition(X:Number, Y:Number) { x = X; y = Y; }		public function setWidth(Width:Number) { width = Width; }		public function setHeight(Height:Number) { height = Height; }		public function setDimensions(Width:Number, Height:Number) { width = Width; height = Height; }		public function setRectangle(Left:Number, Top:Number, Width:Number, Height:Number) { setPosition(Left,Top); setDimensions(Width,Height); }		public function setRandomPosition() { x = 360 + (-1.0 + Math.cos(Math.random()*Math.PI*2)) * 360; y = 310 + (-1.0 + Math.sin(Math.random()*Math.PI*2)) * 360; }				public function GameObject() 		{			super();			animation = new LinkedList();			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onAddedToStage(e:Event)		{			addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		private function onRemovedFromStage(e:Event)		{			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			if (animationTimer != null)			{				animationTimer.stop();				animationTimer.removeEventListener(TimerEvent.TIMER, Update);				animationTimer = null;			}		}		public function Destroy()		{			if (animationTimer != null)			{				animationTimer.stop();				animationTimer.removeEventListener(TimerEvent.TIMER, Update);				animationTimer = null;			}			animation.Clear();			animation = null;						removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}				private function addAnimation(a:Animation)		{			for (var n:int = 0; n < animation.length; n++)			{				if ((animation.Get(n) as Animation).type == a.type)				{					animation.RemoveAt(n);					n--;				}			}			animation.Add(a);						if (animationTimer == null)			{				animationTimer = new Timer(20,0);				animationTimer.addEventListener(TimerEvent.TIMER, Update);				animationTimer.start();			}		}		private function getAnimationByType(type:String) : Animation		{			for (var n:int = 0; n < animation.length; n++)			{				if ((animation.Get(n) as Animation).type == type)				{					return animation.Get(n) as Animation;				}			}			return new Animation();		}		private function removeAnimationByType(type:String)		{			for (var n:int = 0; n < animation.length; n++)			{				if ((animation.Get(n) as Animation).type == type)				{					animation.RemoveAt(n);					return;				}			}		}				public function moveTo(destX:Number, destY:Number, durationInMillis:int, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "move";			a.startX = x;		a.startY = y;			a.endX = destX; 	a.endY = destY;			a.durationInMillis = durationInMillis;			a.onCompleteCallback = onCompleteCallback;			a.startTime = getTimer();						addAnimation(a);		}		public function fadeTo(fadeToAlpha:Number, durationInMillis:int, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "fade";			a.startAlpha = alpha;			a.endAlpha = fadeToAlpha;			a.durationInMillis = durationInMillis;			a.delayedStartInMillis = delayedStartInMillis;			a.onCompleteCallback = onCompleteCallback;			a.startTime = getTimer();						addAnimation(a);		}		public function acceleratedRotation(axis:String, spinUpDuration:int, durationInMillis:int, maximumSpeed:Number, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "accelerated rotation " + axis.toUpperCase();			a.accelerationTimeInMillis = spinUpDuration;			a.durationInMillis = durationInMillis;			a.maxSpeed = maximumSpeed;			a.onCompleteCallback = onCompleteCallback;			a.delayedStartInMillis = delayedStartInMillis;			a.startTime = getTimer();						addAnimation(a);		}		public function rotate(axis:String, degrees:Number, durationInMillis:int, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "rotate" + axis.toUpperCase();			if (axis.toLowerCase() == "x") { a.startX = rotationX; a.endX = degrees; }			if (axis.toLowerCase() == "y") { a.startY = rotationY; a.endY = degrees; }			if (axis.toLowerCase() == "z") { a.startZ = rotationZ; a.endZ = degrees; }			a.durationInMillis = durationInMillis;			a.delayedStartInMillis = delayedStartInMillis;			a.onCompleteCallback = onCompleteCallback;			a.startTime = getTimer();						addAnimation(a);		}		public function flip(durationInMillis:int, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "flipA";			a.durationInMillis = durationInMillis;			a.delayedStartInMillis = delayedStartInMillis;			a.onCompleteCallback = onCompleteCallback;			a.flipped = false;			a.startTime = getTimer();						addAnimation(a);		}		public function blink(durationInMillis:int, inner:Boolean = false, blinkSpeedInMillis:int = 333, blinkColor:uint = 0xFFFFFF, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = "blink";			a.startFilters = filters;			a.durationInMillis = durationInMillis;			a.blinkSpeedInMillis = blinkSpeedInMillis;			a.color = blinkColor;			if (inner) a.glow = new GlowFilter(blinkColor,1.0,9.0,9.0,3,1,true,false);			else a.glow = new GlowFilter(blinkColor,1.0,9.0,9.0,3,1,false,false);			a.onCompleteCallback = onCompleteCallback;			a.startTime = getTimer();			a.lastBlink = getTimer();						addAnimation(a);		}		public function startSpin(speed:Number, blur:GameObject, onCompleteCallback:Function = null, delayedStartInMillis:int = 0)		{			var a:Animation = new Animation();						a.type = Animation.SPIN;			a.maxSpeed = speed;			a.blurredClip = blur;			a.durationInMillis = 10000;			a.onCompleteCallback = onCompleteCallback;			a.startY = y;			a.delayedStartInMillis = delayedStartInMillis;			a.startTime = getTimer();						addAnimation(a);		}		public function stopSpin(yOffset:int, delayedStopInMillis:int = 0, onCompleteCallback:Function = null)		{			var a:Animation = new Animation();						a.type = Animation.SPIN_STOP;			a.startTime = getTimer();			a.delayedStartInMillis = delayedStopInMillis;			a.blurredClip = getAnimationByType(Animation.SPIN).blurredClip;			a.onCompleteCallback = onCompleteCallback;			a.durationInMillis = 1000;			a.endY = -(10 * 128) + yOffset;						addAnimation(a);		}				public function Update(e:TimerEvent = null)		{			for (var n:int = 0; n < animation.length; n++)			{				var a:Animation = animation.Get(n) as Animation;				var now:int = getTimer();								var pctComplete:Number = 0.0;				if (now - a.startTime < a.delayedStartInMillis) pctComplete = 0.0;				else pctComplete = (now - (a.startTime + a.delayedStartInMillis))/a.durationInMillis;				//else if (a.durationInMillis > 0) pctComplete = (now - a.startTime)/(a.durationInMillis + a.delayedStartInMillis);				//else if (a.durationInMillis == 0) pctComplete = 1.0;								// If the time elapsed is greater than or equal to the total time allotted for this motion				if (pctComplete >= 1.0)				{					if (a.type == Animation.MOVE) { x = a.endX; y = a.endY; z = a.endZ; }					else if (a.type == Animation.BLINK) { filters = a.startFilters; }					else if (a.type == "flipA") { (this as Card).flipCard(); rotationY = 180; }					else if (a.type == "flipB") { rotationY = 180; }					else if (a.type == Animation.FADE) { alpha = a.endAlpha; }					else if (a.type == Animation.ROTATE_X) { rotationX = a.endX; }					else if (a.type == Animation.ROTATE_Y) { rotationY = a.endY; }					else if (a.type == Animation.ROTATE_Z) { rotationZ = a.endZ; }					//else if (a.type == Animation.SPIN) { y = a.endY; }					else if (a.type == Animation.SPIN_STOP) { y = a.endY; }										animation.RemoveAt(n);					n--;										if (a.onCompleteCallback != null) a.onCompleteCallback(this);				}				else if (pctComplete > 0.0)				{					if (a.type == Animation.MOVE)					{						x = a.startX + (a.endX - a.startX) * pctComplete;						y = a.startY + (a.endY - a.startY) * pctComplete;					}					else if (a.type == Animation.BLINK)					{						if (now - a.lastBlink > a.blinkSpeedInMillis)						{							if (filters.length > 0) filters = [];							else filters = [a.glow];														a.lastBlink = now;						}					}					else if (a.type == Animation.FADE)					{						if (a.startAlpha > a.endAlpha) alpha = a.startAlpha - (a.startAlpha - a.endAlpha) * pctComplete;						if (a.startAlpha < a.endAlpha) alpha = a.startAlpha + (a.endAlpha - a.startAlpha) * pctComplete;					}					else if (a.type == "flipA")					{						if ((this as Card).isFlipped)						{							rotationY = pctComplete * 180 + 180;							if (rotationY > 270)							{								a.type = "flipB";								(this as Card).flipCard();							}						}						else 						{							rotationY = pctComplete * 180;							if (rotationY > 90)							{								a.type = "flipB";								(this as Card).flipCard();							}						}					}					else if (a.type == "flipB") { rotationY = pctComplete * 180; }					else if (a.type == Animation.ROTATE_X) rotationX = a.startX + (a.endX - a.startX) * pctComplete;					else if (a.type == Animation.ROTATE_Y) rotationY = a.startY + (a.endY - a.startY) * pctComplete;					else if (a.type == Animation.ROTATE_Z) rotationZ = a.startZ + (a.endZ - a.startZ) * pctComplete;					else if (a.type.indexOf("accelerated rotation") >= 0)					{						var axis:String = a.type.substr("accelerated rotation ".length);						var currentRotationSpeed:Number;						if (now - a.startTime < a.accelerationTimeInMillis)							currentRotationSpeed = ((now - a.startTime)/a.accelerationTimeInMillis) * a.maxSpeed;						else if (now - a.startTime > (a.durationInMillis - a.accelerationTimeInMillis))							currentRotationSpeed = a.maxSpeed - ((now - a.startTime - (a.durationInMillis - a.accelerationTimeInMillis))/a.accelerationTimeInMillis) * a.maxSpeed;											else if (now - a.startTime >= a.accelerationTimeInMillis &&								 now - a.startTime <= (a.durationInMillis - a.accelerationTimeInMillis))							currentRotationSpeed = a.maxSpeed;						else							currentRotationSpeed = 0;						if (axis == "Z") 						{							rotationZ += currentRotationSpeed;							while (rotationZ > 360) rotationZ -= 360;						}						else if (axis == "X")						{							rotationX += currentRotationSpeed;							while (rotationX > 360) rotationX -= 360;						}						else if (axis == "Y")						{							rotationY += currentRotationSpeed;							while (rotationY > 360) rotationY -= 360;						}					}					else if (a.type == Animation.SPIN)					{						if (now - (a.startTime + a.delayedStartInMillis) < 1000)						{							var angle:Number = Math.PI * ((now - (a.startTime + a.delayedStartInMillis))/1000);							y = a.startY - Math.sin(angle) * 64;						}						else						{							if (!contains(a.blurredClip)) addChild(a.blurredClip);							a.blurredClip.visible = true;														y += a.maxSpeed;							if (y > 0) y -= height/3;														a.startTime = now - 1000 - a.delayedStartInMillis;						}					}					else if (a.type == Animation.SPIN_STOP)					{						removeAnimationByType(Animation.SPIN);						a.blurredClip.visible = false;													if (now - (a.startTime + a.delayedStartInMillis) < 1000)						{							angle = Math.PI * ((now - (a.startTime + a.delayedStartInMillis))/1000);							y = a.endY + Math.sin(angle) * 64;						}					}				}			}		}	}	}